import { Injectable } from '@angular/core';
import { NumberFormatter } from '../../../formatters/number/number-formatter.service';
import * as i0 from "@angular/core";
import * as i1 from "../../../formatters/number/number-formatter.service";
export const intValidator = (formatter) => ((control) => {
    const invalid = formatter.validateIntUserFormat(control.value);
    return invalid ? {
        intValidator: {
            valid: false,
            format: formatter.getIntUserFormatPattern(),
            message: {
                labelKey: 'LBL_VALIDATION_ERROR_INT_FORMAT',
                context: {
                    value: control.value,
                    expected: formatter.toUserFormat('1000')
                }
            }
        },
    } : null;
});
export class IntValidator {
    constructor(formatter) {
        this.formatter = formatter;
    }
    applies(record, viewField) {
        return (viewField?.type ?? viewField?.fieldDefinition?.type) === 'int';
    }
    getValidator(viewField) {
        if (!(viewField?.type ?? viewField?.fieldDefinition?.type)) {
            return [];
        }
        return [intValidator(this.formatter)];
    }
    static { this.ɵfac = function IntValidator_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || IntValidator)(i0.ɵɵinject(i1.NumberFormatter)); }; }
    static { this.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: IntValidator, factory: IntValidator.ɵfac, providedIn: 'root' }); }
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IntValidator, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i1.NumberFormatter }], null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50LnZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2NvcmUvYXBwL2NvcmUvc3JjL2xpYi9zZXJ2aWNlcy9yZWNvcmQvdmFsaWRhdGlvbi92YWxpZGF0b3JzL2ludC52YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNEJBLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHFEQUFxRCxDQUFDOzs7QUFLcEYsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLENBQUMsU0FBMEIsRUFBdUIsRUFBRSxDQUFDLENBQzdFLENBQUMsT0FBd0IsRUFBbUMsRUFBRTtJQUUxRCxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9ELE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNiLFlBQVksRUFBRTtZQUNWLEtBQUssRUFBRSxLQUFLO1lBQ1osTUFBTSxFQUFFLFNBQVMsQ0FBQyx1QkFBdUIsRUFBRTtZQUMzQyxPQUFPLEVBQUU7Z0JBQ0wsUUFBUSxFQUFFLGlDQUFpQztnQkFDM0MsT0FBTyxFQUFFO29CQUNMLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztvQkFDcEIsUUFBUSxFQUFFLFNBQVMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO2lCQUMzQzthQUNKO1NBQ0o7S0FDSixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDYixDQUFDLENBQ0osQ0FBQztBQUtGLE1BQU0sT0FBTyxZQUFZO0lBRXJCLFlBQXNCLFNBQTBCO1FBQTFCLGNBQVMsR0FBVCxTQUFTLENBQWlCO0lBQ2hELENBQUM7SUFFRCxPQUFPLENBQUMsTUFBYyxFQUFFLFNBQThCO1FBRWxELE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxJQUFJLFNBQVMsRUFBRSxlQUFlLEVBQUUsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFFO0lBQzVFLENBQUM7SUFFRCxZQUFZLENBQUMsU0FBOEI7UUFFdkMsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLElBQUksSUFBSSxTQUFTLEVBQUUsZUFBZSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDekQsT0FBTyxFQUFFLENBQUM7UUFDZCxDQUFDO1FBRUQsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDOzZHQWpCUSxZQUFZO3VFQUFaLFlBQVksV0FBWixZQUFZLG1CQUZULE1BQU07O2lGQUVULFlBQVk7Y0FIeEIsVUFBVTtlQUFDO2dCQUNSLFVBQVUsRUFBRSxNQUFNO2FBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTdWl0ZUNSTSBpcyBhIGN1c3RvbWVyIHJlbGF0aW9uc2hpcCBtYW5hZ2VtZW50IHByb2dyYW0gZGV2ZWxvcGVkIGJ5IFNhbGVzQWdpbGl0eSBMdGQuXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgU2FsZXNBZ2lsaXR5IEx0ZC5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCB1bmRlclxuICogdGhlIHRlcm1zIG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAzIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAqIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiB3aXRoIHRoZSBhZGRpdGlvbiBvZiB0aGUgZm9sbG93aW5nIHBlcm1pc3Npb24gYWRkZWRcbiAqIHRvIFNlY3Rpb24gMTUgYXMgcGVybWl0dGVkIGluIFNlY3Rpb24gNyhhKTogRk9SIEFOWSBQQVJUIE9GIFRIRSBDT1ZFUkVEIFdPUktcbiAqIElOIFdISUNIIFRIRSBDT1BZUklHSFQgSVMgT1dORUQgQlkgU0FMRVNBR0lMSVRZLCBTQUxFU0FHSUxJVFkgRElTQ0xBSU1TIFRIRVxuICogV0FSUkFOVFkgT0YgTk9OIElORlJJTkdFTUVOVCBPRiBUSElSRCBQQVJUWSBSSUdIVFMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICpcbiAqIEluIGFjY29yZGFuY2Ugd2l0aCBTZWN0aW9uIDcoYikgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogdmVyc2lvbiAzLCB0aGVzZSBBcHByb3ByaWF0ZSBMZWdhbCBOb3RpY2VzIG11c3QgcmV0YWluIHRoZSBkaXNwbGF5IG9mIHRoZVxuICogXCJTdXBlcmNoYXJnZWQgYnkgU3VpdGVDUk1cIiBsb2dvLiBJZiB0aGUgZGlzcGxheSBvZiB0aGUgbG9nb3MgaXMgbm90IHJlYXNvbmFibHlcbiAqIGZlYXNpYmxlIGZvciB0ZWNobmljYWwgcmVhc29ucywgdGhlIEFwcHJvcHJpYXRlIExlZ2FsIE5vdGljZXMgbXVzdCBkaXNwbGF5XG4gKiB0aGUgd29yZHMgXCJTdXBlcmNoYXJnZWQgYnkgU3VpdGVDUk1cIi5cbiAqL1xuXG5pbXBvcnQge1ZhbGlkYXRvckludGVyZmFjZX0gZnJvbSAnLi4vdmFsaWRhdG9yLkludGVyZmFjZSc7XG5pbXBvcnQge0Fic3RyYWN0Q29udHJvbH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TnVtYmVyRm9ybWF0dGVyfSBmcm9tICcuLi8uLi8uLi9mb3JtYXR0ZXJzL251bWJlci9udW1iZXItZm9ybWF0dGVyLnNlcnZpY2UnO1xuaW1wb3J0IHtSZWNvcmR9IGZyb20gJy4uLy4uLy4uLy4uL2NvbW1vbi9yZWNvcmQvcmVjb3JkLm1vZGVsJztcbmltcG9ydCB7U3RhbmRhcmRWYWxpZGF0b3JGbiwgU3RhbmRhcmRWYWxpZGF0aW9uRXJyb3JzfSBmcm9tICcuLi8uLi8uLi8uLi9jb21tb24vc2VydmljZXMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLm1vZGVsJztcbmltcG9ydCB7Vmlld0ZpZWxkRGVmaW5pdGlvbn0gZnJvbSAnLi4vLi4vLi4vLi4vY29tbW9uL21ldGFkYXRhL21ldGFkYXRhLm1vZGVsJztcblxuZXhwb3J0IGNvbnN0IGludFZhbGlkYXRvciA9IChmb3JtYXR0ZXI6IE51bWJlckZvcm1hdHRlcik6IFN0YW5kYXJkVmFsaWRhdG9yRm4gPT4gKFxuICAgIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBTdGFuZGFyZFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcblxuICAgICAgICBjb25zdCBpbnZhbGlkID0gZm9ybWF0dGVyLnZhbGlkYXRlSW50VXNlckZvcm1hdChjb250cm9sLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGludmFsaWQgPyB7XG4gICAgICAgICAgICBpbnRWYWxpZGF0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXR0ZXIuZ2V0SW50VXNlckZvcm1hdFBhdHRlcm4oKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsS2V5OiAnTEJMX1ZBTElEQVRJT05fRVJST1JfSU5UX0ZPUk1BVCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGZvcm1hdHRlci50b1VzZXJGb3JtYXQoJzEwMDAnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSA6IG51bGw7XG4gICAgfVxuKTtcblxuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBJbnRWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3JJbnRlcmZhY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGZvcm1hdHRlcjogTnVtYmVyRm9ybWF0dGVyKSB7XG4gICAgfVxuXG4gICAgYXBwbGllcyhyZWNvcmQ6IFJlY29yZCwgdmlld0ZpZWxkOiBWaWV3RmllbGREZWZpbml0aW9uKTogYm9vbGVhbiB7XG5cbiAgICAgICAgcmV0dXJuICh2aWV3RmllbGQ/LnR5cGUgPz8gdmlld0ZpZWxkPy5maWVsZERlZmluaXRpb24/LnR5cGUpID09PSAnaW50JyA7XG4gICAgfVxuXG4gICAgZ2V0VmFsaWRhdG9yKHZpZXdGaWVsZDogVmlld0ZpZWxkRGVmaW5pdGlvbik6IFN0YW5kYXJkVmFsaWRhdG9yRm5bXSB7XG5cbiAgICAgICAgaWYgKCEodmlld0ZpZWxkPy50eXBlID8/IHZpZXdGaWVsZD8uZmllbGREZWZpbml0aW9uPy50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtpbnRWYWxpZGF0b3IodGhpcy5mb3JtYXR0ZXIpXTtcbiAgICB9XG59XG4iXX0=